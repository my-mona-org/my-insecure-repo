name: Dependabot Burner
on:
  schedule:
    - cron: '0 6 * * 1'
  workflow_dispatch:

permissions:
  contents: read
  issues: write
  pull-requests: read

jobs:
  burner:
    runs-on: ubuntu-latest
    steps:
      - name: Run dependabot burner
        uses: actions/github-script@v7
        env:
          INPUT_LABEL: dependabot-burner-input
        with:
          script: |
            const { owner, repo } = context.repo;
            const inputLabel = process.env.INPUT_LABEL || 'dependabot-burner-input';
            const inputTitle = '[dependabot-burner] Input';

            const manifestMatchers = [
              { runtime: 'go', matcher: (p) => p.endsWith('/go.mod') || p === 'go.mod' },
              { runtime: 'java', matcher: (p) => p.endsWith('/pom.xml') || p === 'pom.xml' },
              { runtime: 'node', matcher: (p) => p.endsWith('/package.json') || p === 'package.json' },
              { runtime: 'python', matcher: (p) => p.endsWith('/requirements.txt') || p.endsWith('/pyproject.toml') || p.endsWith('/Pipfile') || p === 'requirements.txt' || p === 'pyproject.toml' || p === 'Pipfile' },
              { runtime: 'ruby', matcher: (p) => p.endsWith('/Gemfile') || p === 'Gemfile' }
            ];

            const dependabotBaseQuery = `repo:${owner}/${repo} is:pr author:app/dependabot`;

            function collectManifestCandidates(filePaths) {
              const candidates = [];
              for (const rule of manifestMatchers) {
                const manifests = filePaths.filter((p) => rule.matcher(p));
                if (manifests.length > 0) {
                  candidates.push({ runtime: rule.runtime, manifests });
                }
              }
              return candidates;
            }

            async function upsertInputIssue(payload) {
              const body = [
                'Input Data:',
                '```json',
                JSON.stringify(payload, null, 2),
                '```',
                '',
                `Updated: ${new Date().toISOString()}`
              ].join('\n');

              const q = `repo:${owner}/${repo} is:issue label:${inputLabel} in:title "${inputTitle}"`;
              const result = await github.rest.search.issuesAndPullRequests({ q, per_page: 5 });
              const existing = result.data.items.find((item) => item.title === inputTitle) || null;

              if (existing) {
                await github.rest.issues.update({
                  owner,
                  repo,
                  issue_number: existing.number,
                  body
                });
                return;
              }

              await github.rest.issues.create({
                owner,
                repo,
                title: inputTitle,
                body,
                labels: [inputLabel]
              });
            }

            const openPrs = await github.paginate(github.rest.search.issuesAndPullRequests, {
              q: `${dependabotBaseQuery} is:open`,
              per_page: 100
            });

            const prPayloads = [];

            for (const pr of openPrs) {
              const prNumber = pr.number;
              const prInfo = await github.rest.pulls.get({ owner, repo, pull_number: prNumber });

              const files = await github.paginate(github.rest.pulls.listFiles, {
                owner,
                repo,
                pull_number: prNumber,
                per_page: 100
              });

              const fileEntries = files.map((file) => ({
                filename: file.filename,
                status: file.status,
                additions: file.additions,
                deletions: file.deletions
              }));

              const fileNames = fileEntries.map((file) => file.filename);

              prPayloads.push({
                number: prInfo.data.number,
                title: prInfo.data.title,
                state: prInfo.data.state,
                draft: prInfo.data.draft,
                merged: Boolean(prInfo.data.merged_at),
                created_at: prInfo.data.created_at,
                updated_at: prInfo.data.updated_at,
                html_url: prInfo.data.html_url,
                labels: (prInfo.data.labels || []).map((label) => label.name),
                files: fileEntries,
                manifest_candidates: collectManifestCandidates(fileNames)
              });
            }

            const weekAgo = new Date(Date.now() - 7 * 24 * 60 * 60 * 1000).toISOString().split('T')[0];
            const openedQuery = `${dependabotBaseQuery} created:>=${weekAgo}`;
            const closedQuery = `${dependabotBaseQuery} is:closed closed:>=${weekAgo}`;

            const openedResult = await github.rest.search.issuesAndPullRequests({ q: openedQuery, per_page: 1 });
            const closedResult = await github.rest.search.issuesAndPullRequests({ q: closedQuery, per_page: 1 });

            const payload = {
              generated_at: new Date().toISOString(),
              open_total: openPrs.length,
              opened_last_7d: openedResult.data.total_count,
              closed_last_7d: closedResult.data.total_count,
              prs: prPayloads
            };

            await upsertInputIssue(payload);
